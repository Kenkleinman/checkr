---
title: "Checking Code Answers"
author: "Daniel Kaplan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include = FALSE}
library(ggplot2)
library(dplyr)
library(checkr)
```

In tutorial systems such as <DataCamp.com> or the `tutor` package in R, problems are posed that call for the student to enter code to solve a stated problem. This package provides a system for checking whether that code has done what's required and, if not, where the problem might fall.

## A trivial example: 2 + 2

To illustrate, consider this trivial problem: Write the code to add two and two. Of course, we expect the student to submit `2 + 2` as the response. But they might have

* submitted nothing
* submitted something like `3 + 1`
* submitted something like `2 / 2`

This package allows you to write test statements that will examine the student's submission to make sure the code was of the submitted form.

A tutorial system will typically collect the student code submissions as text, and may evaluate the code in order to verify that it runs.  Here are a few different possible submissions for the `2 + 2` problem:

```{r}
# three possible submissions to the problem
submission_1 <- "2 + 2" # correct
submission_2 <- "2 / 2" # right arguments but wrong function
submission_3 <- "3 + 2" # right function but wrong arguments
```

One approach to checking these submissions is to compare them to the correct character string, that is, `"2 + 2"`. But if there is not a match, we can't give any guidance other than "that's wrong."

Here are some tests from `checkr` that are relevant. Each test takes the form of a pattern and a message to return if that pattern is not found.
```{r}
library(checkr)
test_1 <- fcall("whatever + whatever", "need to use addition (+)")
test_2 <- fcall("2 + whatever", "first argument should be 2")
test_3 <- fcall("whatever + 2", "second argument should be 2")
```

To use the tests, we need to provide as input the student submission and collect as output the result of the test.  A tutorial system will have provide a way of doing this. For this vignette, which runs outside of any tutorial system, we'll use `capture.code()` to pass the text submission to the test. Similarly, to display the results we'll have a simple function `show_results()`
```{r}
show_results <- function(test_output) {
  if (test_output$passed) return("Passed!")
  else return(paste("Sorry, but", test_output$message))
}
```

Now to run the various tests on the different submissions:
```{r}
capture.code(submission_1) %>% test_1 %>% show_results
capture.code(submission_2) %>% test_1 %>% show_results
```

Submission 1 passed, as expected. Submission 2 failed and the failure message indicates what's wrong with the code.

You may be surprised to see that submission 3, which is wrong, nonetheless passes the test
```{r}
capture.code(submission_3) %>% test_1 %>% show_results
```
This is because `test_1` has been set up to check that the right function is being used, and not to check the arguments. For checking the arguments, `test_2` and `test_3` can be used.


Tests can be strung together in a sequence. Whatever test in the sequence is first to fail will produce the output of the whole string. For example:
```{r}
capture.code(submission_3) %>% test_1 %>% test_2 %>% test_3 %>% show_results
```
`test_1` was passed, but `test_2`, which checks to see that the first argument is `2`, failed. `test_3` was not even run, because `test_2` already failed.

## Framework for testing

Before it can be tested, the student answer must run, even if the answer is not correct.

Each student answer will be broken into command lines. A command line contains a complete R command, even if it appears to be divided into multiple text lines. The command line may include assignment, but does not need to.

There are three basic kinds of tests:

1. A location test. That there exists some command line that matches the specified criterion. Location tests look through the command lines in a student answer to find the match. Location tests have several forms:
    - a character string matches 
    - a specified function (and, optionally, specified arguments) is called
    - assignment to a name is done by the statement.
    Failure to find a location means that the overall test fails. But if the test is passed, you can do additional location tests. At the end of the location-test sequence, you can optionally test for a final value of the last-located command, or the argument to a function in that last-located command.
2. A final value test. The value computed by that located line matches a specified criterion.
3. An argument test value. An argument to a function invoked on the located line matches a specified argument.

Before you can apply tests of a value or an argument, a line must have been previously located. So a location test should always be the first test in every sequence. [[I can't decide whether one-line answers should be able to skip the locator.]]

Using `then()` and `previously()` enables you to specify that a given locator test should match the code before or after a previous locator test.

## A richer example

Here's a problem that's more difficult: Using `ggplot()`, make a scatterplot of miles-per-gallon versus horsepower in the `mtcars` data.

Let's look at these possible submissions:

```{r}
submission_1 <- "ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point()" # Wrong!
submission_2 <- "ggplot(mtcars, aes(x = hp, y = mpg)) + geom_line()" # Wrong!
submission_3 <- "ggplot(mtcars, aes(y = mpg, x = hp)) + geom_point()" # right
submission_4 <- "ggplot(mtcars) + geom_point(aes(y = mpg, x = hp))" # also right
submission_5 <- c(
"my_cars <- mtcars",
"ggplot(my_cars, aes(y = mpg, x = hp)) + geom_point()")
submission_6 <- c(
"my_cars <- mtcars %>% select(mpg, hp)",
"ggplot(my_cars, aes(y = mpg, x = hp)) + geom_point()")
```

Submission 1 has the roles of the variables `mpg` and `hp` reversed from the problem statement. Submission 2 uses `geom_line()` instead of the required `geom_point()`. Submissions 3 and 4 will all create the specified plot, but each is arranged in a different way.

Here are some tests. Remember, the second argument is the message to return if the test *fails*.
```{r}
test_1 <- fcall("aes(x = hp, y = whatever)", "variable 'hp' goes on the x axis")
test_2 <- fcall("aes(y = mpg, x = whatever)", "variable 'mpg' goes on the y axis")
test_3 <- fcall("geom_point()", "include a 'geom_point()' layer")
test_4 <- in_statements("mtcars") 
test_5 <- fcall("ggplot(data = whatever)", "no data handed to ggplot()")
test_6 <- check_argument("ggplot(data = grab_this)", test = match_class("data.frame"))
test_7 <- check_argument("ggplot(data = grab_this)", match_data_frame(mtcars))
test_8 <- check_argument("ggplot(data = grab_this)", 
                         match_data_frame(mtcars, diag = TRUE))
test_9 <- check_argument("ggplot(data = grab_this)",
                         match_data_frame(
                           mtcars %>% select(hp, mpg, carb), 
                           diag = TRUE))
```

We'll chain these seven tests together and see the results for the different submissions.
```{r}
capture.code(submission_1) %>% 
  test_1 %>% test_2 %>% test_3 %>% test_4 %>% test_5 %>% test_6 %>% test_7 %>% 
  show_results
capture.code(submission_2) %>%
  test_1 %>% test_2 %>% test_3 %>% test_4 %>% test_5 %>% test_6 %>% test_7 %>%
  show_results
capture.code(submission_3) %>% 
  test_1 %>% test_2 %>% test_3 %>% test_4 %>% test_5 %>% test_6 %>% test_7 %>% 
  show_results
capture.code(submission_4) %>%
  test_1 %>% test_2 %>% test_3 %>% test_4 %>% test_5 %>% test_6 %>% test_7 %>%
  show_results
```

These examples show passes and fails when checking the value of an argument to a function.

```{r}
capture.code(submission_5) %>%
  test_5 %>% test_7 %>%
  show_results
capture.code(submission_6) %>%
  test_5 %>% test_7 %>%
  show_results
capture.code(submission_6) %>%
  test_5 %>% test_8 %>%
  show_results
capture.code(submission_6) %>%
  test_5 %>% test_9 %>%
  show_results

```
  

## Checking values

Each command produces a value. You have access to these, both named and unnamed. 

For instance, this command does some arithmetic and creates a `ggplot` object.

```{r}
submission_1 <- "
3 + 5
ggplot(mtcars, aes(y = mpg, x = hp)) + geom_point()" 
```

A simple test for this is:
```{r}
test_1 <- in_values(class = "ggplot")
capture.code(submission_1) %>%
  test_1 %>%
  show_results
```

But if we were looking for a `lattice` graphics object, the submission fails:
```{r}
test_2 <- in_values(class = "lattice")
capture.code(submission_1) %>%
  test_2 %>%
  show_results
```

If either would suffice ...
```{r}
test_3 <- either(test_1, test_2)
capture.code(submission_1) %>%
  test_3 %>%
  show_results
```

Suppose that we want to check that a number near 8 is created ...
```{r}
test_4 <- in_values(number = c(7.9, 8.1))
capture.code(submission_1) %>% test_4 %>%
  show_results
```

## Checking the value itself


A sequence of odd numbers from 11 to 31 (inclusive) using the colon operator.

```{r}
submission_1 <- capture.code("seq(11, 31, by = 2)") # right value, but not what was asked
submission_2 <- capture.code("11 + 2*(0:10)") # right
submission_3 <- capture.code("11 + 2*(1:11)") # uses colon, but wrong result

```

```{r}
test_1 <- fcall("whatever : whatever", "you didn't use the colon operator")
test_2 <- check_value(match_vector(seq(11, 31, by = 2), diag = TRUE))

submission_1 %>% test_1 %>% test_2 %>% show_results
submission_2 %>% test_1 %>% test_2 %>% show_results
submission_3 %>% test_1 %>% test_2 %>% show_results
```



Suppose we ask the student to construct a somewhat complicated object that we want to run some checks on. For instance, "Construct a model of `mpg` versus `hp` using `wt` as a covariate."

```{r}
submission_1 <- capture.code("lm(mpg ~ hp, data = mtcars)")  # wrong
submission_2 <- capture.code("lm(mpg ~ hp + wt, data = mtcars)") # right
submission_3 <- capture.code("lm(mpg ~ wt, data = mtcars)") # wrong
```

```{r}
test_1 <- fcall("lm(data = mtcars)", "use lm() on mtcars data")
test_2 <- check_value(function(x) {'wt' %in% names(coef(x))}, 
                      "what about the covariate wt?")
test_3 <- check_value(function(x) {all(c("hp", "wt") %in% names(coef(x)))}, 
                      'include both hp and the covariate as explanatory variables')
test_4 <- check_argument("lm(formula = grab_this)", match_formula(mpg ~ hp + wt))
```

```{r}
submission_1 %>% test_1 %>% test_2 %>% test_3 %>% show_results
submission_2 %>% test_1 %>% test_2 %>% test_3 %>% show_results
submission_3 %>% test_1 %>% test_2 %>% test_3 %>% show_results
submission_1 %>% test_1 %>% test_4 %>% show_results
submission_3 %>% test_1 %>% test_4 %>% show_results
```

## Magrittr pipelines

Magrittr pipelines are translated into a sequence of commands. For instance,
```
foobar <- mtcars %>% filter(mpg > 15) %>% select(mpg)
```
will be evaluated as if it were
```
filter(mtcars, mpg > 15) -> ..tmp1..
select(..tmp1.., mpg) -> foobar
```

This allows tests to be constructed as if each step in the chain were a separate command; the test statements can be constructed in the ordinary way. Do remember that the first argument to `dplyr` data verbs is `.data =`.


```{r}
submission_1 <- capture.code("foobar <- mtcars %>% filter(mpg > 15)")
test_1 <- fcall("filter()", "should call filter()")
test_2 <- check_argument("mpg > grab_this", match_number(15))
test_2A <- check_argument("mpg > grab_this", match_number(16))
test_3 <- check_argument("filter(.data = grab_this)", match_data_frame(iris, diag = TRUE))
submission_1 %>% test_1 %>% test_2 %>% test_3 %>% show_results
submission_1 %>% test_1 %>% test_2A %>% test_3 %>% show_results

```

STILL NEED TO HANDLE INTERNAL CHAINS and EXPLICIT "dot" arguments.

This is not working. I think I need a new check_argument_symbol() that won't try to evaluate the symbols.
```{r eval = FALSE}
submission_2 <- capture.code("mtcars %>% filter(mpg > 15) %>% group_by(cyl) %>% summarise(mmpg = mean(mpg))")
test_4 <- fcall("group_by()")
test_5 <- check_argument("group_by(.data = whatever, grab_this)", function(x) x)
submission_2 %>% test_4 %>% test_5
```
